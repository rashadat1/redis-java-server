import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.HashMap;

public class XaddCommand implements RedisCommand {
    String streamName;
    String streamId;
    HashMap<String, Stream> streamMap;
    HashMap<String, String> streamData;

    public XaddCommand(String streamName, String streamId, HashMap<String, Stream> streamMap, HashMap<String, String> streamData) {
        this.streamName = streamName;
        this.streamId = streamId;
        this.streamMap = streamMap;
        this.streamData = streamData;
    }
    private void processStreamId() {
        // generates full stream id if partially or fully autogenerated, creates new stream
        boolean fullyAutoGeneratedId = this.streamId.equals("*");
        String[] entryParts = streamId.split("-");
        
        boolean partiallyAutoGeneratedId = (!entryParts[0].equals("*") && entryParts[1].equals("*"));
        if (!this.streamMap.containsKey(this.streamName)) {
            // this is a new stream we are creating
            Stream newStream = new Stream();
            if (partiallyAutoGeneratedId) {
                if (entryParts[0].equals("0")) {
                    this.streamId = "0-1";
                } else {
                    this.streamId = entryParts[0] + "-0";
                }
            } else if (fullyAutoGeneratedId) {
                this.streamId = String.valueOf(System.currentTimeMillis()) + "-0";
            }
            this.streamMap.put(this.streamName, newStream);
        } else {
            Stream retrievedStream = this.streamMap.get(this.streamName);
            String lastId = retrievedStream.lastID;
            if (partiallyAutoGeneratedId) {
                if (lastId.split("-")[0].equals(entryParts[0])) {
                    this.streamId = entryParts[0] + "-" + String.valueOf(Long.parseLong(lastId.split("-")[1] + 1));
                } else {
                    this.streamId = entryParts[0] + "-0";
                }
            } else if (fullyAutoGeneratedId) {
                long timeForId = System.currentTimeMillis();
                this.streamId = (timeForId > Long.parseLong(lastId.split("-")[0])) ? String.valueOf(timeForId) + "-0" : String.valueOf(timeForId) + "-" + String.valueOf(Long.parseLong(lastId.split("-")[1]) + 1);

            }

        }
    }
    @Override
    public StringBuilder processCommand() {
        boolean result;
        this.processStreamId(); 
        Stream retrievedStream = this.streamMap.get(this.streamName);
        StreamNode nodeToInsert = new StreamNode(this.streamId, this.streamData);
        result = retrievedStream.insertNewNode(nodeToInsert);
        if (!result) {
            if (this.streamId.equals("0-0") || Long.parseLong(this.streamId.split("-")[0]) < Long.parseLong("0")) {
                return new StringBuilder("-ERR The ID specified in XADD must be greater than 0-0\r\n");
            } else {
                return new StringBuilder("-ERR The ID specified in XADD is equal or smaller than the target stream top item\r\n");
            }
        } else {
            StringBuilder xaddResponse = new StringBuilder("$");
            xaddResponse.append(this.streamId.length());
            xaddResponse.append("\r\n").append(streamId).append("\r\n");
            return xaddResponse;
        }
    }
    public void propagateToPendingXreads(ArrayList<XReadBlock> blockingTimeoutXreads, ArrayList<XReadBlock> blockingNoTimeoutXreads) {
        ArrayList<XReadBlock> timeoutToRemove = new ArrayList<>();
        ArrayList<XReadBlock> noTimeoutToRemove = new ArrayList<>();
        if (!blockingTimeoutXreads.isEmpty()) {
            System.out.println("Finished parsing and performing XADD, checking if xreads can be resolved (blocking)");
            for (XReadBlock xread : blockingTimeoutXreads) {
                XreadCommand xreadCommand = new XreadCommand(null, this.streamMap, xread.streamsWaitingOn, xread.lowBoundId, 0, false);
                StringBuilder xreadResponse = xreadCommand.processCommand();
                if (!xreadResponse.toString().equals("$-1\r\n")) {
                    System.out.println("This Xadd resolved a blocking Xread with timeout!");  
                    timeoutToRemove.add(xread);
                    StringBuilder starter = new StringBuilder("*").append(xreadCommand.numNodesWithDataRead).append("\r\n");
                    try {
                        xread.channel.write(ByteBuffer.wrap((starter.toString() + xreadResponse.toString()).getBytes()));
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
        if (!blockingNoTimeoutXreads.isEmpty()) {
            for (XReadBlock xread : blockingNoTimeoutXreads) {
                XreadCommand xreadCommand = new XreadCommand(null, this.streamMap, xread.streamsWaitingOn, xread.lowBoundId, 0, false);
                StringBuilder xreadResponse = xreadCommand.processCommand();
                if (!xreadResponse.toString().equals("$-1\r\n")) {
                    System.out.println("This Xadd resolved a blocking Xread without timeout!");
                    noTimeoutToRemove.add(xread);
                    StringBuilder starter = new StringBuilder("*").append(xreadCommand.numNodesWithDataRead).append("\r\n");
                    try {
                        xread.channel.write(ByteBuffer.wrap((starter.toString() + xreadResponse.toString()).getBytes()));
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
        blockingTimeoutXreads.removeAll(timeoutToRemove);
        blockingNoTimeoutXreads.removeAll(noTimeoutToRemove);
    }
}
